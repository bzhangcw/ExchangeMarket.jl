var documenterSearchIndex = {"docs":
[{"location":"api/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"This page documents the market models available in ExchangeMarket.jl.","category":"page"},{"location":"api/models/#Fisher-Market","page":"Models","title":"Fisher Market","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"The main market type in ExchangeMarket.jl is FisherMarket, which supports CES (Constant Elasticity of Substitution) utilities.","category":"page"},{"location":"api/models/#Constructor","page":"Models","title":"Constructor","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"FisherMarket(m, n; ρ=0.0, bool_unit=true, scale=1.0, sparsity=1.0)","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"Parameters:","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"m: Number of agents/buyers\nn: Number of goods\nρ: CES elasticity parameter (default: 0.0 for Cobb-Douglas)\nbool_unit: Whether to use unit utilities (default: true)\nscale: Scaling factor for utilities (default: 1.0)\nsparsity: Sparsity of utility matrix (default: 1.0)","category":"page"},{"location":"api/models/#Example","page":"Models","title":"Example","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"# Create a Fisher market with CES utilities\nRandom.seed!(1)\nn = 500  # number of goods\nm = 1000 # number of agents\nρ = 0.5  # CES elasticity parameter\n\nf0 = FisherMarket(m, n; ρ=ρ, bool_unit=true, scale=30.0, sparsity=0.2)","category":"page"},{"location":"api/models/#Market-Properties","page":"Models","title":"Market Properties","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"The FisherMarket object contains:","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"f0.w: Agent endowments\nf0.c: Utility matrix (sparse)\nf0.p: Current prices\nf0.x: Current allocations\nf0.σ: Substitution elasticity (σ = ρ/(1-ρ))","category":"page"},{"location":"api/models/#Linear-Constraints","page":"Models","title":"Linear Constraints","text":"","category":"section"},{"location":"api/models/#LinearConstr","page":"Models","title":"LinearConstr","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"Linear constraints for market optimization problems.","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"LinearConstr(n_constraints, n_vars, A, b)","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"Parameters:","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"n_constraints: Number of constraint equations\nn_vars: Number of variables\nA: Constraint matrix\nb: Constraint right-hand side","category":"page"},{"location":"api/models/#Example-2","page":"Models","title":"Example","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"# Create budget constraint: sum of prices equals total wealth\nlinconstr = LinearConstr(1, n, ones(1, n), [sum(f0.w)])","category":"page"},{"location":"api/models/#Market-Initialization","page":"Models","title":"Market Initialization","text":"","category":"section"},{"location":"api/models/#Setting-Initial-Prices-and-Allocations","page":"Models","title":"Setting Initial Prices and Allocations","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"# Initialize with uniform prices and allocations\np₀ = ones(n) * sum(f0.w) ./ n  # Uniform initial prices\nx₀ = ones(n, m) ./ m           # Uniform initial allocations\nf0.x .= x₀\nf0.p .= p₀","category":"page"},{"location":"api/models/#Market-Validation","page":"Models","title":"Market Validation","text":"","category":"section"},{"location":"api/models/#validate","page":"Models","title":"validate","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"Validate market equilibrium to ensure all constraints are satisfied.","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"validate(f0, alg)","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"This function outputs:","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"Problem size information\nEquilibrium validation results  \nMarket excess (should be near zero)\nSocial welfare","category":"page"},{"location":"api/models/#Example-Output","page":"Models","title":"Example Output","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"------------------------------------------------------------\n :problem size\n :    number of agents: 1000\n :    number of goods: 500\n :    avg number of nonzero entries in c: 0.1997\n :equilibrium information\n :method: HessianBar\n------------------------------------------------------------\n10×2 DataFrame\n Row │ utility    left_budget  \n     │ Float64    Float64      \n─────┼──────────────────────────\n   1 │ 1.24158e-7   0.0\n   2 │ 3.80644e-6  -2.1684e-19\n   ...\n------------------------------------------------------------\n :(normalized) market excess: [-5.6658e-10, 5.1747e-10]\n :            social welfare:  -1.30839518e+01\n------------------------------------------------------------","category":"page"},{"location":"api/models/#Utility-Functions","page":"Models","title":"Utility Functions","text":"","category":"section"},{"location":"api/models/#CES-Utilities","page":"Models","title":"CES Utilities","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"The package supports CES (Constant Elasticity of Substitution) utilities:","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"U(x) = (∑ᵢ αᵢ xᵢ^ρ)^(1/ρ)","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"where:","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"ρ is the elasticity parameter\nσ = ρ/(1-ρ) is the substitution elasticity\nαᵢ are the CES parameters","category":"page"},{"location":"api/models/#Parameter-Ranges","page":"Models","title":"Parameter Ranges","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"ρ ∈ [-∞, 1): CES parameter\nρ = 0: Cobb-Douglas utilities (limit)\nρ = -∞: Leontief utilities (limit)\nρ = 1: Linear utilities (limit)","category":"page"},{"location":"api/models/#Market-Properties-2","page":"Models","title":"Market Properties","text":"","category":"section"},{"location":"api/models/#Equilibrium-Conditions","page":"Models","title":"Equilibrium Conditions","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"A valid market equilibrium satisfies:","category":"page"},{"location":"api/models/","page":"Models","title":"Models","text":"Budget Balance: Each agent spends exactly their endowment value\nMarket Clearing: Total demand equals total supply for each good\nIndividual Rationality: Each agent gets non-negative utility\nPareto Efficiency: No reallocation can make everyone better off","category":"page"},{"location":"api/models/#Economic-Interpretation","page":"Models","title":"Economic Interpretation","text":"","category":"section"},{"location":"api/models/","page":"Models","title":"Models","text":"Prices: Reflect relative scarcity and preferences\nAllocations: Optimal consumption bundles given prices\nEquilibrium: No agent wants to change their consumption given prices ","category":"page"},{"location":"examples/fisher_market/#Fisher-Market-Example","page":"Fisher Market","title":"Fisher Market Example","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"This example demonstrates how to use ExchangeMarket.jl to solve Fisher market equilibrium problems with CES utilities.","category":"page"},{"location":"examples/fisher_market/#Problem-Setup","page":"Fisher Market","title":"Problem Setup","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"We'll solve a Fisher market with:","category":"page"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"1000 agents (buyers)\n500 goods\nCES utilities with different elasticity parameters\nMultiple optimization algorithms","category":"page"},{"location":"examples/fisher_market/#Complete-Example","page":"Fisher Market","title":"Complete Example","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"using ExchangeMarket\nusing Random, SparseArrays, LinearAlgebra\nusing JuMP, MosekTools\nusing Plots, LaTeXStrings, Printf\n\n# Set random seed for reproducibility\nRandom.seed!(1)\n\n# Market parameters\nrrange = [-0.9, 0.9]  # CES elasticity parameters to test\nn = 500   # number of goods\nm = 1000  # number of agents\n\n# Filter for specific methods\nmethod_filter(name) = name ∈ [:LogBar, :PathFol, :Tât, :PropRes]\n\n# Store results\ntable_time = []\nresults = []\nresults_phi = Dict()\nresults_ground = Dict()\n\n# Test different ρ values\nfor ρ in rrange\n    # Create Fisher market with CES utilities\n    f0 = FisherMarket(m, n; ρ=ρ, bool_unit=true, scale=30.0, sparsity=0.2)\n    linconstr = LinearConstr(1, n, ones(1, n), [sum(f0.w)])\n    \n    ρfmt = @sprintf(\"%+.2f\", ρ)\n    σfmt = @sprintf(\"%+.2f\", f0.σ)\n    \n    println(\"Testing ρ = $ρfmt (σ = $σfmt)\")\n    \n    # -----------------------------------------------------------------------\n    # Compute ground truth using HessianBar\n    # -----------------------------------------------------------------------\n    f1 = copy(f0)\n    p₀ = ones(n) * sum(f1.w) ./ n\n    x₀ = ones(n, m) ./ m\n    f1.x .= x₀\n    f1.p .= p₀\n    \n    # Use HessianBar to compute ground truth\n    alg = HessianBar(n, m, p₀; linconstr=linconstr)\n    traj = opt!(alg, f1; keep_traj=true)\n    \n    pₛ = copy(alg.p)  # Ground truth prices\n    results_phi[ρ] = pₛ\n    results_ground[ρ] = (alg, traj, f1)\n    \n    # Test different algorithms\n    for (name, method) in [\n        (:HessianBar, HessianBar),\n        (:PathFol, PathFol),\n        (:Tât, Tât),\n        (:PropRes, PropRes)\n    ]\n        !method_filter(name) && continue\n        \n        f1 = copy(f0)\n        p₀ = ones(n) * sum(f1.w) ./ n\n        x₀ = ones(n, m) ./ m\n        f1.x .= x₀\n        f1.p .= p₀\n        \n        alg = method(n, m, p₀; linconstr=linconstr)\n        traj = opt!(alg, f1; keep_traj=true, pₛ=pₛ, maxiter=500)\n        \n        push!(results, ((name, ρ), (alg, traj, f1)))\n        push!(table_time, (n, m, name, ρ, traj[end].t))\n        \n        println(\"  $name: $(traj[end].t) seconds\")\n    end\nend","category":"page"},{"location":"examples/fisher_market/#Validation","page":"Fisher Market","title":"Validation","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"After computing solutions, validate the results:","category":"page"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"# Validate ground truth solutions\nfor (ρ, (alg, traj, f1)) in results_ground\n    println(\"Validating ρ = $ρ\")\n    validate(f1, alg)\nend","category":"page"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"This will output validation information including:","category":"page"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"Problem size\nEquilibrium validation results\nMarket excess (should be near zero)\nSocial welfare","category":"page"},{"location":"examples/fisher_market/#Convergence-Analysis","page":"Fisher Market","title":"Convergence Analysis","text":"","category":"section"},{"location":"examples/fisher_market/#Plotting-Convergence-Trajectories","page":"Fisher Market","title":"Plotting Convergence Trajectories","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"# Plot distance to equilibrium for each ρ and method\nfor ρ in rrange\n    ρfmt = @sprintf(\"%+.2f\", ρ)\n    σfmt = @sprintf(\"%+.2f\", ρ / (1 - ρ))\n    \n    fig = plot(\n        ylabel=L\"$\\|\\mathbf{p} - \\mathbf{p}^*\\|$\",\n        title=L\"$\\rho := %$ρfmt~(\\sigma := %$σfmt)$\",\n        legendbackgroundcolor=RGBA(1.0, 1.0, 1.0, 0.8),\n        yticks=10.0 .^ (-16:4:3),\n        xtickfont=font(18),\n        ytickfont=font(18),\n        xscale=:identity,\n        size=(1200, 600)\n    )\n    \n    for ((name, _ρ), (alg, traj, f1)) in results\n        if _ρ != ρ\n            continue\n        end\n        \n        traj_pp₊ = map(pp -> pp.D, traj)\n        traj_tt₊ = map(pp -> pp.k, traj)\n        \n        plot!(fig, traj_tt₊, traj_pp₊, \n              label=L\"\\texttt{%$name}\", \n              linewidth=2, \n              linestyle=:dash, \n              markershape=:circle)\n    end\n    \n    display(fig)\nend","category":"page"},{"location":"examples/fisher_market/#Performance-Comparison","page":"Fisher Market","title":"Performance Comparison","text":"","category":"section"},{"location":"examples/fisher_market/#Timing-Analysis","page":"Fisher Market","title":"Timing Analysis","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"# Create timing table\nusing DataFrames\n\ndf = DataFrame(\n    n=Int[],\n    m=Int[],\n    method=Symbol[],\n    ρ=Float64[],\n    time=Float64[]\n)\n\nfor (n, m, method, ρ, time) in table_time\n    push!(df, (n, m, method, ρ, time))\nend\n\n# Display results\nprintln(\"Performance Summary:\")\nprintln(df)","category":"page"},{"location":"examples/fisher_market/#Algorithm-Comparison","page":"Fisher Market","title":"Algorithm Comparison","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"# Compare convergence rates\nfor ρ in rrange\n    println(\"ρ = $ρ:\")\n    for ((name, _ρ), (alg, traj, f1)) in results\n        if _ρ == ρ\n            final_dist = traj[end].D\n            iterations = length(traj)\n            println(\"  $name: $iterations iterations, final distance: $final_dist\")\n        end\n    end\nend","category":"page"},{"location":"examples/fisher_market/#Key-Insights","page":"Fisher Market","title":"Key Insights","text":"","category":"section"},{"location":"examples/fisher_market/#CES-Parameter-Effects","page":"Fisher Market","title":"CES Parameter Effects","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"ρ = -0.9: High substitution elasticity (σ ≈ 0.47), goods are close substitutes\nρ = 0.0: Cobb-Douglas utilities (σ = 1), moderate substitution\nρ = 0.9: Low substitution elasticity (σ ≈ 9), goods are complements","category":"page"},{"location":"examples/fisher_market/#Algorithm-Performance","page":"Fisher Market","title":"Algorithm Performance","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"HessianBar: Best for large problems, quadratic convergence\nPathFol: Robust convergence, good for poor initialization\nTât: Simple and fast for small problems\nPropRes: Intuitive interpretation, slower convergence","category":"page"},{"location":"examples/fisher_market/#Convergence-Patterns","page":"Fisher Market","title":"Convergence Patterns","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"All methods converge to the same equilibrium\nConvergence rate depends on ρ value\nHessianBar shows fastest convergence for well-conditioned problems\nPathFol is most robust to different ρ values","category":"page"},{"location":"examples/fisher_market/#Advanced-Features","page":"Fisher Market","title":"Advanced Features","text":"","category":"section"},{"location":"examples/fisher_market/#Custom-Utility-Parameters","page":"Fisher Market","title":"Custom Utility Parameters","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"# Test with different utility parameters\nf0 = FisherMarket(m, n; \n    ρ=0.5,           # CES elasticity\n    bool_unit=true,   # Unit utilities\n    scale=30.0,       # Utility scaling\n    sparsity=0.2      # Matrix sparsity\n)","category":"page"},{"location":"examples/fisher_market/#Linear-Constraints","page":"Fisher Market","title":"Linear Constraints","text":"","category":"section"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"# Add custom linear constraints\nA = [ones(1, n); rand(2, n)]  # 3 constraints\nb = [sum(f0.w); rand(2)]      # Right-hand sides\nlinconstr = LinearConstr(3, n, A, b)","category":"page"},{"location":"examples/fisher_market/","page":"Fisher Market","title":"Fisher Market","text":"This example demonstrates the full workflow of using ExchangeMarket.jl for Fisher market equilibrium computation, from problem setup to solution validation and performance analysis. ","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will help you get started with ExchangeMarket.jl using real examples from the package.","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ExchangeMarket.jl requires Julia 1.6 or later. You can download Julia from julialang.org.","category":"page"},{"location":"getting_started/#Installing-the-Package","page":"Getting Started","title":"Installing the Package","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"ExchangeMarket\")","category":"page"},{"location":"getting_started/#Required-Dependencies","page":"Getting Started","title":"Required Dependencies","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For the examples in this guide, you'll also need:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"JuMP\")\nPkg.add(\"MosekTools\")  # For MOSEK solver\nPkg.add(\"Plots\")       # For visualization\nPkg.add(\"LaTeXStrings\") # For LaTeX labels","category":"page"},{"location":"getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting_started/#Loading-the-Package","page":"Getting Started","title":"Loading the Package","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using ExchangeMarket\nusing Random, SparseArrays, LinearAlgebra\nusing JuMP, MosekTools\nusing Plots, LaTeXStrings, Printf","category":"page"},{"location":"getting_started/#Creating-a-Fisher-Market","page":"Getting Started","title":"Creating a Fisher Market","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The main market type in ExchangeMarket.jl is FisherMarket, which supports CES (Constant Elasticity of Substitution) utilities.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Set random seed for reproducibility\nRandom.seed!(1)\n\n# Market parameters\nn = 500  # number of goods\nm = 1000 # number of agents  \nρ = 0.5  # CES elasticity parameter\n\n# Create Fisher market with CES utilities\nf0 = FisherMarket(m, n; ρ=ρ, bool_unit=true, scale=30.0, sparsity=0.2)","category":"page"},{"location":"getting_started/#Setting-Up-Constraints","page":"Getting Started","title":"Setting Up Constraints","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ExchangeMarket.jl supports linear constraints on the market:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create linear constraint (e.g., total budget constraint)\nlinconstr = LinearConstr(1, n, ones(1, n), [sum(f0.w)])","category":"page"},{"location":"getting_started/#Initializing-the-Market","page":"Getting Started","title":"Initializing the Market","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Initialize prices and allocations\np₀ = ones(n) * sum(f0.w) ./ n  # Uniform initial prices\nx₀ = ones(n, m) ./ m           # Uniform initial allocations\nf0.x .= x₀\nf0.p .= p₀","category":"page"},{"location":"getting_started/#Solving-the-Market","page":"Getting Started","title":"Solving the Market","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ExchangeMarket.jl provides several algorithms for finding market equilibrium:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Method 1: Hessian Barrier Method\nalg = HessianBar(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)\n\n# Method 2: Path Following\nalg = PathFol(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)\n\n# Method 3: Tâtonnement\nalg = Tât(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)\n\n# Method 4: Proportional Response\nalg = PropRes(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)","category":"page"},{"location":"getting_started/#Validating-Results","page":"Getting Started","title":"Validating Results","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Validate the computed equilibrium\nvalidate(f0, alg)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This will output:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Problem size information\nEquilibrium validation results\nMarket excess (should be near zero)\nSocial welfare","category":"page"},{"location":"getting_started/#Advanced-Usage","page":"Getting Started","title":"Advanced Usage","text":"","category":"section"},{"location":"getting_started/#Testing-Different-Elasticity-Parameters","page":"Getting Started","title":"Testing Different Elasticity Parameters","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Test different ρ values\nrrange = [-0.9, 0.9]\nresults = []\n\nfor ρ in rrange\n    f0 = FisherMarket(m, n; ρ=ρ, bool_unit=true, scale=30.0, sparsity=0.2)\n    linconstr = LinearConstr(1, n, ones(1, n), [sum(f0.w)])\n    \n    # Initialize\n    p₀ = ones(n) * sum(f0.w) ./ n\n    x₀ = ones(n, m) ./ m\n    f0.x .= x₀\n    f0.p .= p₀\n    \n    # Solve with different methods\n    for (name, method) in [(:HessianBar, HessianBar), (:PathFol, PathFol)]\n        alg = method(n, m, p₀; linconstr=linconstr)\n        traj = opt!(alg, f0; keep_traj=true, maxiter=500)\n        push!(results, (name, ρ, traj))\n    end\nend","category":"page"},{"location":"getting_started/#Analyzing-Convergence","page":"Getting Started","title":"Analyzing Convergence","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Plot convergence trajectories\nfor (name, ρ, traj) in results\n    iterations = [t.k for t in traj]\n    distances = [t.D for t in traj]\n    \n    plot(iterations, distances, \n         label=\"$name (ρ=$ρ)\", \n         xlabel=\"Iteration\", \n         ylabel=\"Distance to equilibrium\",\n         yscale=:log10)\nend","category":"page"},{"location":"getting_started/#Troubleshooting","page":"Getting Started","title":"Troubleshooting","text":"","category":"section"},{"location":"getting_started/#Common-Issues","page":"Getting Started","title":"Common Issues","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Solver not found: Make sure you have MOSEK installed and licensed\nConvergence issues: Try different initial conditions or algorithm parameters\nMemory issues: For large markets, consider using sparse matrices","category":"page"},{"location":"getting_started/#Performance-Tips","page":"Getting Started","title":"Performance Tips","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Use sparsity parameter to control matrix density\nAdjust scale parameter for different problem sizes\nMonitor convergence with keep_traj=true","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Check out the Examples for more detailed use cases\nExplore the API Reference for complete function documentation\nRead the Tutorials for advanced features and techniques ","category":"page"},{"location":"api/utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"This page documents the utility functions and constants in ExchangeMarket.jl.","category":"page"},{"location":"api/utils/#Logging-and-Output","page":"Utilities","title":"Logging and Output","text":"","category":"section"},{"location":"api/utils/#LOGDIR","page":"Utilities","title":"LOGDIR","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Directory for storing log files.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"println(\"Logs stored in: \", LOGDIR)","category":"page"},{"location":"api/utils/#RESULTSDIR","page":"Utilities","title":"RESULTSDIR","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Directory for storing results.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"println(\"Results stored in: \", RESULTSDIR)","category":"page"},{"location":"api/utils/#pprint","page":"Utilities","title":"pprint","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Formatted printing function for consistent output.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"pprint(\"Market equilibrium found\", level=:info)","category":"page"},{"location":"api/utils/#Mathematical-Utilities","page":"Utilities","title":"Mathematical Utilities","text":"","category":"section"},{"location":"api/utils/#logbar","page":"Utilities","title":"logbar","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Logarithmic barrier function for optimization.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"barrier_value = logbar(x, mu)","category":"page"},{"location":"api/utils/#powerp*to*cone!","page":"Utilities","title":"powerptocone!","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Transform power utility to conic form.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"cone_data = powerp_to_cone!(data, p=2.0)","category":"page"},{"location":"api/utils/#proj","page":"Utilities","title":"proj","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Projection onto feasible set.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"projected_point = proj(x, constraints)","category":"page"},{"location":"api/utils/#extract*standard*form","page":"Utilities","title":"extractstandardform","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Extract standard form from optimization problem.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"A, b, c = extract_standard_form(problem)","category":"page"},{"location":"api/utils/#Validation-and-Testing","page":"Utilities","title":"Validation and Testing","text":"","category":"section"},{"location":"api/utils/#validate","page":"Utilities","title":"validate","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Validate market equilibrium to ensure all constraints are satisfied.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"validate(f0, alg)","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"This function outputs:","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Problem size information\nEquilibrium validation results\nMarket excess (should be near zero)\nSocial welfare","category":"page"},{"location":"api/utils/#Example-Output","page":"Utilities","title":"Example Output","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"------------------------------------------------------------\n :problem size\n :    number of agents: 1000\n :    number of goods: 500\n :    avg number of nonzero entries in c: 0.1997\n :equilibrium information\n :method: HessianBar\n------------------------------------------------------------\n10×2 DataFrame\n Row │ utility    left_budget  \n     │ Float64    Float64      \n─────┼──────────────────────────\n   1 │ 1.24158e-7   0.0\n   2 │ 3.80644e-6  -2.1684e-19\n   ...\n------------------------------------------------------------\n :(normalized) market excess: [-5.6658e-10, 5.1747e-10]\n :            social welfare:  -1.30839518e+01\n------------------------------------------------------------","category":"page"},{"location":"api/utils/#Configuration","page":"Utilities","title":"Configuration","text":"","category":"section"},{"location":"api/utils/#__default*jump*solver","page":"Utilities","title":"__defaultjumpsolver","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Default solver for JuMP optimization problems.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"__default_jump_solver = :mosek","category":"page"},{"location":"api/utils/#__default_sep","page":"Utilities","title":"__default_sep","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Default separator for output formatting.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"println(__default_sep)","category":"page"},{"location":"api/utils/#Data-Structures","page":"Utilities","title":"Data Structures","text":"","category":"section"},{"location":"api/utils/#ResponseInfo","page":"Utilities","title":"ResponseInfo","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Information structure for response-based algorithms.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"response_info = ResponseInfo(\n    market=f0,\n    algorithm=:hessianbar,\n    max_iterations=1000\n)","category":"page"},{"location":"api/utils/#File-Operations","page":"Utilities","title":"File Operations","text":"","category":"section"},{"location":"api/utils/#save_results","page":"Utilities","title":"save_results","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Save market results to file.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"save_results(market, \"fisher_market_results.jld2\")","category":"page"},{"location":"api/utils/#load_results","page":"Utilities","title":"load_results","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Load results from file.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"loaded_market = load_results(\"fisher_market_results.jld2\")","category":"page"},{"location":"api/utils/#Performance-Monitoring","page":"Utilities","title":"Performance Monitoring","text":"","category":"section"},{"location":"api/utils/#benchmark_solve","page":"Utilities","title":"benchmark_solve","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Benchmark market solution performance.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"timing = benchmark_solve(market, n_runs=10)","category":"page"},{"location":"api/utils/#profile_market","page":"Utilities","title":"profile_market","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Profile market performance.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"profile_data = profile_market(market)","category":"page"},{"location":"api/utils/#Visualization","page":"Utilities","title":"Visualization","text":"","category":"section"},{"location":"api/utils/#plot_market","page":"Utilities","title":"plot_market","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Plot market equilibrium.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"plot_market(market, result)","category":"page"},{"location":"api/utils/#plot_convergence","page":"Utilities","title":"plot_convergence","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Plot convergence history.","category":"page"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"plot_convergence(convergence_data)","category":"page"},{"location":"api/utils/#Error-Handling","page":"Utilities","title":"Error Handling","text":"","category":"section"},{"location":"api/utils/#Common-Error-Messages","page":"Utilities","title":"Common Error Messages","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Solver not found: Make sure you have the required solvers installed\nConvergence issues: Try different initial conditions or algorithm parameters\nMemory issues: For large markets, consider using sparse matrices","category":"page"},{"location":"api/utils/#Debugging-Tips","page":"Utilities","title":"Debugging Tips","text":"","category":"section"},{"location":"api/utils/","page":"Utilities","title":"Utilities","text":"Enable detailed logging with set_log_level!(market, :debug)\nMonitor convergence with keep_traj=true\nCheck market validation with validate(f0, alg) ","category":"page"},{"location":"tutorials/basic_usage/#Basic-Usage-Tutorial","page":"Basic Usage","title":"Basic Usage Tutorial","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"This tutorial will guide you through the fundamental concepts and usage patterns of ExchangeMarket.jl using real examples from the package.","category":"page"},{"location":"tutorials/basic_usage/#Prerequisites","page":"Basic Usage","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Before starting this tutorial, make sure you have:","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Julia 1.6 or later installed\nExchangeMarket.jl installed: using Pkg; Pkg.add(\"ExchangeMarket\")","category":"page"},{"location":"tutorials/basic_usage/#Installation","page":"Basic Usage","title":"Installation","text":"","category":"section"},{"location":"tutorials/basic_usage/#Installing-the-Package","page":"Basic Usage","title":"Installing the Package","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using Pkg\nPkg.add(\"ExchangeMarket\")","category":"page"},{"location":"tutorials/basic_usage/#Required-Dependencies","page":"Basic Usage","title":"Required Dependencies","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"For the examples in this guide, you'll also need:","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using Pkg\nPkg.add(\"JuMP\")\nPkg.add(\"MosekTools\")  # For MOSEK solver\nPkg.add(\"Plots\")       # For visualization\nPkg.add(\"LaTeXStrings\") # For LaTeX labels","category":"page"},{"location":"tutorials/basic_usage/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"tutorials/basic_usage/#Loading-the-Package","page":"Basic Usage","title":"Loading the Package","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using ExchangeMarket\nusing Random, SparseArrays, LinearAlgebra\nusing JuMP, MosekTools\nusing Plots, LaTeXStrings, Printf","category":"page"},{"location":"tutorials/basic_usage/#Creating-a-Fisher-Market","page":"Basic Usage","title":"Creating a Fisher Market","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The main market type in ExchangeMarket.jl is FisherMarket, which supports CES (Constant Elasticity of Substitution) utilities.","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Set random seed for reproducibility\nRandom.seed!(1)\n\n# Market parameters\nn = 500  # number of goods\nm = 1000 # number of agents  \nρ = 0.5  # CES elasticity parameter\n\n# Create Fisher market with CES utilities\nf0 = FisherMarket(m, n; ρ=ρ, bool_unit=true, scale=30.0, sparsity=0.2)","category":"page"},{"location":"tutorials/basic_usage/#Setting-Up-Constraints","page":"Basic Usage","title":"Setting Up Constraints","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"ExchangeMarket.jl supports linear constraints on the market:","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Create linear constraint (e.g., total budget constraint)\nlinconstr = LinearConstr(1, n, ones(1, n), [sum(f0.w)])","category":"page"},{"location":"tutorials/basic_usage/#Initializing-the-Market","page":"Basic Usage","title":"Initializing the Market","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Initialize prices and allocations\np₀ = ones(n) * sum(f0.w) ./ n  # Uniform initial prices\nx₀ = ones(n, m) ./ m           # Uniform initial allocations\nf0.x .= x₀\nf0.p .= p₀","category":"page"},{"location":"tutorials/basic_usage/#Solving-the-Market","page":"Basic Usage","title":"Solving the Market","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"ExchangeMarket.jl provides several algorithms for finding market equilibrium:","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Method 1: Hessian Barrier Method\nalg = HessianBar(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)\n\n# Method 2: Path Following\nalg = PathFol(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)\n\n# Method 3: Tâtonnement\nalg = Tât(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)\n\n# Method 4: Proportional Response\nalg = PropRes(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)","category":"page"},{"location":"tutorials/basic_usage/#Validating-Results","page":"Basic Usage","title":"Validating Results","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Validate the computed equilibrium\nvalidate(f0, alg)","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"This will output:","category":"page"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Problem size information\nEquilibrium validation results\nMarket excess (should be near zero)\nSocial welfare","category":"page"},{"location":"tutorials/basic_usage/#Advanced-Usage","page":"Basic Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"tutorials/basic_usage/#Testing-Different-Elasticity-Parameters","page":"Basic Usage","title":"Testing Different Elasticity Parameters","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Test different ρ values\nrrange = [-0.9, 0.9]\nresults = []\n\nfor ρ in rrange\n    f0 = FisherMarket(m, n; ρ=ρ, bool_unit=true, scale=30.0, sparsity=0.2)\n    linconstr = LinearConstr(1, n, ones(1, n), [sum(f0.w)])\n    \n    # Initialize\n    p₀ = ones(n) * sum(f0.w) ./ n\n    x₀ = ones(n, m) ./ m\n    f0.x .= x₀\n    f0.p .= p₀\n    \n    # Solve with different methods\n    for (name, method) in [(:HessianBar, HessianBar), (:PathFol, PathFol)]\n        alg = method(n, m, p₀; linconstr=linconstr)\n        traj = opt!(alg, f0; keep_traj=true, maxiter=500)\n        push!(results, (name, ρ, traj))\n    end\nend","category":"page"},{"location":"tutorials/basic_usage/#Analyzing-Convergence","page":"Basic Usage","title":"Analyzing Convergence","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"# Plot convergence trajectories\nfor (name, ρ, traj) in results\n    iterations = [t.k for t in traj]\n    distances = [t.D for t in traj]\n    \n    plot(iterations, distances, \n         label=\"$name (ρ=$ρ)\", \n         xlabel=\"Iteration\", \n         ylabel=\"Distance to equilibrium\",\n         yscale=:log10)\nend","category":"page"},{"location":"tutorials/basic_usage/#Troubleshooting","page":"Basic Usage","title":"Troubleshooting","text":"","category":"section"},{"location":"tutorials/basic_usage/#Common-Issues","page":"Basic Usage","title":"Common Issues","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Solver not found: Make sure you have MOSEK installed and licensed\nConvergence issues: Try different initial conditions or algorithm parameters\nMemory issues: For large markets, consider using sparse matrices","category":"page"},{"location":"tutorials/basic_usage/#Performance-Tips","page":"Basic Usage","title":"Performance Tips","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Use sparsity parameter to control matrix density\nAdjust scale parameter for different problem sizes\nMonitor convergence with keep_traj=true","category":"page"},{"location":"tutorials/basic_usage/#Next-Steps","page":"Basic Usage","title":"Next Steps","text":"","category":"section"},{"location":"tutorials/basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Check out the Examples for more detailed use cases\nExplore the API Reference for complete function documentation\nRead the Tutorials for advanced features and techniques ","category":"page"},{"location":"#ExchangeMarket.jl","page":"Home","title":"ExchangeMarket.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for competitive exchange market optimization and analysis.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExchangeMarket.jl provides a comprehensive framework for modeling and solving competitive exchange market problems. The package includes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fisher Market Models: Implementation of Fisher market equilibrium computation\nCES Market Models: Constant Elasticity of Substitution market formulations  \nConic Optimization: Advanced optimization algorithms using conic programming\nLinear Systems: Efficient solvers for linear systems arising in market computations\nMirror Descent: Implementation of mirror descent algorithms for market optimization","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using ExchangeMarket\nusing Random, SparseArrays, LinearAlgebra\nusing JuMP, MosekTools\n\n# Create a Fisher market with CES utilities\nRandom.seed!(1)\nn = 500  # number of goods\nm = 1000 # number of agents\nρ = 0.5  # CES elasticity parameter\n\n# Create Fisher market\nf0 = FisherMarket(m, n; ρ=ρ, bool_unit=true, scale=30.0, sparsity=0.2)\n\n# Set up linear constraints\nlinconstr = LinearConstr(1, n, ones(1, n), [sum(f0.w)])\n\n# Initialize prices and allocations\np₀ = ones(n) * sum(f0.w) ./ n\nx₀ = ones(n, m) ./ m\nf0.x .= x₀\nf0.p .= p₀\n\n# Solve using Hessian barrier method\nalg = HessianBar(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)\n\n# Validate results\nvalidate(f0, alg)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ExchangeMarket\")","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multiple Market Types: Support for Fisher markets, CES markets, and general exchange markets\nAdvanced Algorithms: Conic optimization, mirror descent, and response-based algorithms\nEfficient Solvers: Specialized linear system solvers for market computations\nExtensible Framework: Modular design allowing easy extension to new market types\nComprehensive Utilities: Logging, validation, and analysis tools","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Getting Started: Learn the basics of using ExchangeMarket.jl\nAPI Reference: Complete documentation of all functions and types\nExamples: Step-by-step examples for common use cases\nTutorials: In-depth tutorials for advanced features","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ExchangeMarket.jl in your research, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{zhang2024exchangemarket,\n  title={ExchangeMarket.jl: A Julia Package for Competitive Exchange Market Optimization},\n  author={Zhang, Chuwen},\n  year={2024},\n  url={https://github.com/yourusername/ExchangeMarket.jl}\n}","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We welcome contributions! Please see our Contributing Guidelines for details.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT License - see the LICENSE file for details. ","category":"page"},{"location":"api/algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"This page documents the optimization algorithms available in ExchangeMarket.jl.","category":"page"},{"location":"api/algorithms/#Available-Algorithms","page":"Algorithms","title":"Available Algorithms","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"ExchangeMarket.jl provides several algorithms for finding market equilibrium:","category":"page"},{"location":"api/algorithms/#HessianBar","page":"Algorithms","title":"HessianBar","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"Hessian barrier method for interior point optimization.","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"alg = HessianBar(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)","category":"page"},{"location":"api/algorithms/#PathFol","page":"Algorithms","title":"PathFol","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"Path following method for market equilibrium.","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"alg = PathFol(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)","category":"page"},{"location":"api/algorithms/#Tât","page":"Algorithms","title":"Tât","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"Tâtonnement (price adjustment) method.","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"alg = Tât(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)","category":"page"},{"location":"api/algorithms/#PropRes","page":"Algorithms","title":"PropRes","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"Proportional response method.","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"alg = PropRes(n, m, p₀; linconstr=linconstr)\ntraj = opt!(alg, f0; keep_traj=true, maxiter=500)","category":"page"},{"location":"api/algorithms/#Algorithm-Comparison","page":"Algorithms","title":"Algorithm Comparison","text":"","category":"section"},{"location":"api/algorithms/#Testing-Different-Methods","page":"Algorithms","title":"Testing Different Methods","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"# Test different algorithms on the same problem\nmethods = [\n    (:HessianBar, HessianBar),\n    (:PathFol, PathFol),\n    (:Tât, Tât),\n    (:PropRes, PropRes)\n]\n\nresults = []\nfor (name, method) in methods\n    alg = method(n, m, p₀; linconstr=linconstr)\n    traj = opt!(alg, f0; keep_traj=true, maxiter=500)\n    push!(results, (name, traj))\nend","category":"page"},{"location":"api/algorithms/#Convergence-Analysis","page":"Algorithms","title":"Convergence Analysis","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"# Plot convergence trajectories\nfor (name, traj) in results\n    iterations = [t.k for t in traj]\n    distances = [t.D for t in traj]\n    \n    plot(iterations, distances, \n         label=name, \n         xlabel=\"Iteration\", \n         ylabel=\"Distance to equilibrium\",\n         yscale=:log10)\nend","category":"page"},{"location":"api/algorithms/#Algorithm-Parameters","page":"Algorithms","title":"Algorithm Parameters","text":"","category":"section"},{"location":"api/algorithms/#Common-Parameters","page":"Algorithms","title":"Common Parameters","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"All algorithms accept these common parameters:","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"n: Number of goods\nm: Number of agents\np₀: Initial prices\nlinconstr: Linear constraints","category":"page"},{"location":"api/algorithms/#opt!-Function","page":"Algorithms","title":"opt! Function","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"The main optimization function:","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"opt!(alg, f0; keep_traj=true, maxiter=500, pₛ=nothing)","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"Parameters:","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"alg: Algorithm object\nf0: Fisher market object\nkeep_traj: Whether to keep trajectory (default: true)\nmaxiter: Maximum iterations (default: 500)\npₛ: Ground truth prices for comparison (optional)","category":"page"},{"location":"api/algorithms/#Trajectory-Analysis","page":"Algorithms","title":"Trajectory Analysis","text":"","category":"section"},{"location":"api/algorithms/#Trajectory-Object","page":"Algorithms","title":"Trajectory Object","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"The opt! function returns a trajectory containing:","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"t.k: Iteration number\nt.t: Time elapsed\nt.D: Distance to equilibrium\nt.φ: Objective value\nt.∇φ: Gradient norm\nt.Δp: Price change norm","category":"page"},{"location":"api/algorithms/#Example-Trajectory-Output","page":"Algorithms","title":"Example Trajectory Output","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"running Phase I...\n      k |  lg(μ) |             φ |    |∇φ| |    |Δp| |       t |      tₗ |       α |     kᵢ \n      0 |  -5.40 | -1.450859e+01 | 1.1e+01 | 4.5e-02 | 0.0e+00 | 4.0e-01 | 1.0e+00 | 2.0e+00 \n--------------------------------------------------------------------------------------------\nrunning Phase II...\n      k |  lg(μ) |             φ |    |∇φ| |    |Δp| |       t |      tₗ |       α |     kᵢ \n      1 |  -5.40 | -1.208262e+01 | 8.4e-01 | 3.2e-03 | 1.0e+00 | 4.1e-01 | 1.0e+00 | 2.0e+00 \n      2 |  -7.48 | -1.208395e+01 | 6.2e-02 | 2.1e-04 | 1.0e+00 | 4.1e-01 | 1.0e+00 | 2.0e+00 \n      3 | -10.72 | -1.208395e+01 | 6.1e-04 | 2.1e-06 | 1.0e+00 | 4.2e-01 | 1.0e+00 | 2.0e+00 \n      4 | -14.02 | -1.208395e+01 | 8.6e-06 | 3.3e-08 | 1.0e+00 | 4.2e-01 | 1.0e+00 | 2.0e+00 \n      5 | -17.32 | -1.208395e+01 | 1.9e-07 | 7.3e-10 | 1.0e+00 | 4.2e-01 | 1.0e+00 | 2.0e+00 ","category":"page"},{"location":"api/algorithms/#Performance-Comparison","page":"Algorithms","title":"Performance Comparison","text":"","category":"section"},{"location":"api/algorithms/#Algorithm-Characteristics","page":"Algorithms","title":"Algorithm Characteristics","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"HessianBar: Interior point method, good for large problems\nPathFol: Path following, robust convergence\nTât: Simple price adjustment, fast for small problems\nPropRes: Proportional response, intuitive interpretation","category":"page"},{"location":"api/algorithms/#Convergence-Properties","page":"Algorithms","title":"Convergence Properties","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"HessianBar: Quadratic convergence, requires good initial point\nPathFol: Linear convergence, robust to poor initialization\nTât: Linear convergence, simple implementation\nPropRes: Sublinear convergence, intuitive behavior","category":"page"},{"location":"api/algorithms/#Advanced-Usage","page":"Algorithms","title":"Advanced Usage","text":"","category":"section"},{"location":"api/algorithms/#Custom-Algorithm-Parameters","page":"Algorithms","title":"Custom Algorithm Parameters","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"# Custom parameters for HessianBar\nalg = HessianBar(n, m, p₀; \n    linconstr=linconstr,\n    μ₀=1e-3,      # Initial barrier parameter\n    tol=1e-8,     # Tolerance\n    maxiter=1000   # Maximum iterations\n)","category":"page"},{"location":"api/algorithms/#Algorithm-Selection","page":"Algorithms","title":"Algorithm Selection","text":"","category":"section"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"Choose algorithm based on problem characteristics:","category":"page"},{"location":"api/algorithms/","page":"Algorithms","title":"Algorithms","text":"Large problems (n, m > 1000): Use HessianBar or PathFol\nSmall problems (n, m < 100): Use Tât or PropRes\nPoor initialization: Use PathFol\nGood initialization: Use HessianBar ","category":"page"},{"location":"api/linsys/#Linear-Systems","page":"Linear Systems","title":"Linear Systems","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"This page documents the linear system solvers and utilities in ExchangeMarket.jl.","category":"page"},{"location":"api/linsys/#Linear-System-Solvers","page":"Linear Systems","title":"Linear System Solvers","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"The package includes efficient solvers for linear systems arising in market computations.","category":"page"},{"location":"api/linsys/#Basic-Linear-System-Solving","page":"Linear Systems","title":"Basic Linear System Solving","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"# Solve linear system Ax = b\nA = rand(10, 10)\nb = rand(10)\nx = A \\ b","category":"page"},{"location":"api/linsys/#Krylov-Methods","page":"Linear Systems","title":"Krylov Methods","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"Krylov subspace methods for large-scale problems.","category":"page"},{"location":"api/linsys/#Example","page":"Linear Systems","title":"Example","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"# Use iterative methods for large systems\nusing IterativeSolvers\n\n# Solve with CG method\nx = cg(A, b)","category":"page"},{"location":"api/linsys/#DRQ-Updates","page":"Linear Systems","title":"DRQ Updates","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"Diagonal + Rank-q updates for efficient matrix operations.","category":"page"},{"location":"api/linsys/#Example-2","page":"Linear Systems","title":"Example","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"# Efficient rank-1 updates\nA = rand(100, 100)\nu = rand(100)\nv = rand(100)\n\n# Sherman-Morrison update: A + uv'\nA_updated = A + u * v'","category":"page"},{"location":"api/linsys/#Matrix-Operations","page":"Linear Systems","title":"Matrix Operations","text":"","category":"section"},{"location":"api/linsys/#Sherman-Morrison-Woodbury-Updates","page":"Linear Systems","title":"Sherman-Morrison-Woodbury Updates","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"Efficient matrix updates for rank modifications.","category":"page"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"# Sherman-Morrison formula\n# (A + uv')^(-1) = A^(-1) - (A^(-1)u v'A^(-1))/(1 + v'A^(-1)u)\n\nfunction sherman_morrison_update!(A_inv, u, v)\n    w = A_inv * u\n    z = A_inv' * v\n    denominator = 1 + dot(v, w)\n    A_inv .-= (w * z') / denominator\nend","category":"page"},{"location":"api/linsys/#Preconditioners","page":"Linear Systems","title":"Preconditioners","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"Preconditioning techniques for iterative solvers.","category":"page"},{"location":"api/linsys/#Example-3","page":"Linear Systems","title":"Example","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"# Diagonal preconditioner\nfunction diagonal_preconditioner(A)\n    diag(A)\nend\n\n# Use with solver\nprecond = diagonal_preconditioner(A)","category":"page"},{"location":"api/linsys/#Iterative-Solvers","page":"Linear Systems","title":"Iterative Solvers","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"Iterative methods for large linear systems.","category":"page"},{"location":"api/linsys/#Example-4","page":"Linear Systems","title":"Example","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"# Conjugate gradient method\nfunction conjugate_gradient(A, b, tol=1e-6, max_iter=1000)\n    n = length(b)\n    x = zeros(n)\n    r = copy(b)\n    p = copy(r)\n    \n    for iter in 1:max_iter\n        Ap = A * p\n        alpha = dot(r, r) / dot(p, Ap)\n        x .+= alpha * p\n        r_new = r - alpha * Ap\n        \n        if norm(r_new) < tol\n            break\n        end\n        \n        beta = dot(r_new, r_new) / dot(r, r)\n        p = r_new + beta * p\n        r = r_new\n    end\n    \n    return x\nend","category":"page"},{"location":"api/linsys/#Direct-Solvers","page":"Linear Systems","title":"Direct Solvers","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"Direct methods for small to medium systems.","category":"page"},{"location":"api/linsys/#Example-5","page":"Linear Systems","title":"Example","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"# LU decomposition\nfunction lu_solve(A, b)\n    F = lu(A)\n    return F \\ b\nend\n\n# Cholesky decomposition (for symmetric positive definite)\nfunction cholesky_solve(A, b)\n    F = cholesky(A)\n    return F \\ b\nend","category":"page"},{"location":"api/linsys/#Utility-Functions","page":"Linear Systems","title":"Utility Functions","text":"","category":"section"},{"location":"api/linsys/#Condition-Number","page":"Linear Systems","title":"Condition Number","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"# Compute condition number\nfunction condition_number(A)\n    σ = svd(A).S\n    return σ[1] / σ[end]\nend","category":"page"},{"location":"api/linsys/#Residual-Norm","page":"Linear Systems","title":"Residual Norm","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"# Compute residual norm\nfunction residual_norm(A, x, b)\n    return norm(A * x - b)\nend","category":"page"},{"location":"api/linsys/#Performance-Considerations","page":"Linear Systems","title":"Performance Considerations","text":"","category":"section"},{"location":"api/linsys/#Sparse-Matrices","page":"Linear Systems","title":"Sparse Matrices","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"For large sparse systems, use sparse matrix formats:","category":"page"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"using SparseArrays\n\n# Create sparse matrix\nA_sparse = sprand(1000, 1000, 0.01)\nb = rand(1000)\n\n# Solve sparse system\nx = A_sparse \\ b","category":"page"},{"location":"api/linsys/#Memory-Efficiency","page":"Linear Systems","title":"Memory Efficiency","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"For very large systems, consider:","category":"page"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"Iterative methods: Use CG, GMRES, or BiCGSTAB\nPreconditioning: Apply appropriate preconditioners\nSparse storage: Use compressed formats\nBlock operations: Exploit matrix structure","category":"page"},{"location":"api/linsys/#Integration-with-ExchangeMarket.jl","page":"Linear Systems","title":"Integration with ExchangeMarket.jl","text":"","category":"section"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"Linear system solvers are used internally by the optimization algorithms:","category":"page"},{"location":"api/linsys/","page":"Linear Systems","title":"Linear Systems","text":"HessianBar: Uses direct solvers for Newton steps\nPathFol: Uses iterative solvers for path following\nTât: Uses simple matrix operations for price updates\nPropRes: Uses basic linear algebra for proportional updates ","category":"page"}]
}
